Subject: GPT 5.2 vs ω-categories — Re: [FOM] Autoformalization getting easy?

Dear Josef Urban, dear FOM,

Indeed, as soon as you can setup some « MathOps » (i.e. math DevOps engineering) for a long-running “LLM ↔ proof-checker” feedback loop (fast checker + minimal trusted core library) then your “≈130k lines in two weeks” as reported in arXiv:2601.03298 is totally feasible. 

Emdash v2 — Functorial programming for strict/lax ω-categories in Lambdapi [ `https://github.com/hotdocx/emdash` ] is such a "core library", and once that loop is tight, GPT 5.2 with Codex CLI can sustain large formal developments. Key learning: "mathops/devops engineering" matters: Gemini 3 Pro + Gemini CLI was bad (even if maybe Gemini 3 Pro defeats GPT 5.2 in "pure thinking").


## 1) Dependent comma/arrow for a dependent category (`homd_cov` in emdash2.lp)

We use displayed/dependent categories over a base category B (morally a fibration E : B → Cat, i.e. a displayed category over B).

For:
- b₀ ∈ B and e₀ ∈ E(b₀).

Then the dependent comma/arrow (“dependent hom”, triangle classifier) is the functor
- Homd_E(e₀, –) : E ×_B (Hom_B(b₀, –))ᵒᵖ → Cat.

On a base arrow b₀₁ : b₀ → b₁ and a fibre object e₁ ∈ E(b₁), it returns the fibre hom-category
- Hom_{E(b₁)}( (b₀₁)! e₀ , e₁ ).

This is the entry point for iterating simplicially (triangles → tetrahedra → …) with rewriting as normalization.

And the functoriality of `Homd_E(e₀, –)`, especially in the second argument  `(Hom_B(b₀, –))ᵒᵖ`, espresses precisely the "stacking" of 2-cells along 1-cells (generalized horizontal composition of 2-cells).

- A key learning is that an **internal** computational-logic for lax ω-categories is easier to express, by Lambdapi and AI agents, than for only strict 1-categories; because the hom-part of a category `Hom(x,–)` is recursively a (fibred) category and the hom-part of a functor `F₁ : Hom(x,–) → Hom(F₀ x, F₀ –)` is recursively a (non-cartesian) fibred functor. (`fapp1_funcd` in emdash2.lp)

## 2) MathOps and arrowgram diagrams specification

One MathOps requirement was to enable the AI coding agent to (natively) understand and generate commutative diagrams; therefore I built **arrowgram**: a strict JSON specification for commutative diagrams, meant to be understood and generated by AI coding agents. `arrowgram` https://github.com/hotdocx/arrowgram/ is open-source and comes with an AI diagram editor/generator exporting JSON/SVG/PNG/TikZ, and a paper document editor that renders markdown with embedded arrowgram diagrams (and with KaTeX + Mermaid + Vega-Lite via Paged.js). And the host app `LastRevision` https://hotdocx.github.io adds an extra academic-publisher (i.e. "sharing") layer on top of this new `arrowgram` paper format.


Best regards,
— m— / emdash project

---

Appendix: Arrowgram JSON specs

1) “Stacking along a 1-cell” as a tetrahedral over-a-base-edge picture (schematic)

```json
{
  "version": 1,
  "nodes": [
    { "name": "v0", "label": "$\\bullet$",      "left": 0,   "top": 150 },
    { "name": "v1", "label": "$b_0\\ \\bullet$", "left": 190, "top": 0   },
    { "name": "v2", "label": "$\\bullet\\ b_1$", "left": 190, "top": 150 },
    { "name": "v3", "label": "$\\bullet\\ b_2$", "left": 300, "top": 265 }
  ],
  "arrows": [
    { "name": "e0", "label": "$e_0$",    "from": "v0", "to": "v1", "label_alignment": "right", "style": { "level": 1 } },
    { "name": "e1", "label": "$e_1$",    "from": "v0", "to": "v2", "label_alignment": "left",  "style": { "level": 1 } },
    { "name": "e3", "label": "$b_{01}$", "from": "v1", "to": "v2", "label_alignment": "left",  "style": { "level": 1 } },
    { "name": "e2", "label": "$b_{12}$", "from": "v2", "to": "v3", "label_alignment": "left",  "style": { "level": 1, "body": { "name": "dashed" } } },
    { "name": "e4", "label": "$b_{02}$", "from": "v1", "to": "v3", "label_alignment": "right", "style": { "level": 1, "body": { "name": "dashed" } } },
    { "name": "e5", "label": "$e_2$",    "from": "v0", "to": "v3", "label_alignment": "left",  "style": { "level": 1, "body": { "name": "dashed" } } },
    { "name": "e01", "label": "$e_{01}$", "from": "e0", "to": "e1", "label_alignment": "right", "style": { "level": 2 } },
    { "name": "e12", "label": "$e_{12}$", "from": "e1", "to": "e5", "label_alignment": "right", "style": { "level": 2 } },
    { "name": "b012op", "label": "$b_{012}^{op}$", "from": "e4", "to": "e2", "label_alignment": "left", "style": { "level": 2 } }
  ]
}
```
