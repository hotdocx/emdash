Excellent. This is a very insightful and well-motivated design choice. Moving away from a separate `ProofSession` object towards a model where the **term-in-progress is the state** is a more functional, "manifest," and ultimately more robust approach. It aligns perfectly with the goals of being transparent and easy for an AI to manipulate.

Your intuition is spot on. This design philosophy is powerful. Let's formalize it.

### Part 1: Review and Analysis of the "Stateless" Vision

Your idea is not only feasible but is arguably a more elegant and modern design for an interactive theorem prover kernel.

**Core Principles of this Architecture:**

1.  **The Proof is a Term:** A proof-in-progress is not managed by an external object. It *is* a `Term` data structure that contains one or more unsolved `Hole`s. The entire state of the proof is encoded within this single, immutable (or structurally-sharing) value.
2.  **Tactics are Term Transformations:** A "tactic" is a pure function: `(Term, ...args) => Term`. It takes the current proof term and returns a *new* proof term where a specific hole has been refined. History/undo is trivial—it's just keeping a list of the terms.
3.  **State is Manifest, Not Hidden:** An AI (or a human developer) can look at the `Term` data structure at any point and see everything. There are no hidden goal stacks or session variables. The goals *are* the holes. Their context is determined by their position within the term's structure.
4.  **Inspection over Reporting:** Instead of a `proof.status()` method, we will have utility functions that *inspect* a given term and generate a report about its unsolved holes, their types, and their contexts.

This design sidesteps the complexities of managing a stateful object and focuses on the core activity: transforming a term until it is complete.

---

### Part 2: Detailed Design and Architecture

Let's design the necessary data structures and functions based on this philosophy.

#### 2.1. The `Hole` Data Structure (Refined)

Your `Hole` structure is a great start. Let's refine it to explicitly hold the information we need for interactive proving.

```typescript
// From your core 'emdash' implementation
import { Term } from './core';

// Represents the local context for display and type-checking purposes.
type GoalContext = { name: string; type: Term }[];

interface Hole {
  tag: 'Hole';
  id: string; // A unique ID, e.g., "?1", "?2"

  // The solution to the hole. `null` if unsolved.
  // When a hole is refined, this field is filled.
  // Core functions like `normalize` or `toString` should "look through" solved holes.
  ref: Term | null; 

  // The type that this hole is expected to fulfill. This is the "goal type".
  // This field is populated by the type checker during hole creation/elaboration.
  type: Term;

  // The local context in which this hole exists. Also populated during elaboration.
  // This is primarily for displaying the goal state to the user.
  // The *real* context is implicit in the HOAS term structure.
  context: GoalContext; 
}
```
**Crucial Point:** The `type` and `context` fields on a `Hole` are *elaborated information*. They are computed by the system when a hole is first created or when the proof term is inspected. They are a cache of what would otherwise require a traversal of the term each time.

#### 2.2. The Kernel's Awareness of Holes

Your core `emdash` kernel functions must be updated to handle holes correctly:
*   **`normalize(term)`**: If it encounters a `Hole` with a non-null `ref`, it should recursively call `normalize` on the `ref`. If the `ref` is `null`, it returns the hole itself.
*   **`toString(term)`**: Same as `normalize`. It should print the content of a solved hole and a placeholder (like its `id`) for an unsolved one.
*   **`check(ctx, term, type)` / `infer(ctx, term)`**: The bidirectional type checker is the engine that creates and elaborates holes. When it encounters a user-provided placeholder (e.g., a special `_?` term), it:
    1.  Creates a new `Hole` object with a fresh `id` and `ref: null`.
    2.  In `check` mode (`check(ctx, _?, type)`), it sets `hole.type = type` and `hole.context = ctx`.
    3.  In `infer` mode, it assigns a fresh meta-variable to the hole's type, and after unification succeeds, it replaces the meta-variable with the solved type on `hole.type`.
    4.  It returns the `Hole` term.

#### 2.3. The "Tactic" and Inspector Functions

These are standalone functions, not methods of a class.

**1. Inspector Functions (for reporting)**

```typescript
/**
 * Creates the initial proof term, which is a single unsolved hole.
 */
function createGoal(type: Term): Term {
  // The context is initially empty.
  const initialHole: Hole = {
    tag: 'Hole',
    id: generateUniqueId(), // e.g., "?1"
    ref: null,
    type: type,
    context: [],
  };
  return initialHole;
}

/**
 * Traverses a term and returns a flat list of all *unsolved* holes.
 */
function findHoles(term: Term): Hole[] {
  const holes: Hole[] = [];
  // This requires a recursive traversal of the term structure.
  // It should look through solved holes (`hole.ref != null`).
  function traverse(t: Term) {
    if (t.tag === 'Hole' && t.ref === null) {
      holes.push(t);
    } else if (t.tag === 'Hole' && t.ref !== null) {
      traverse(t.ref);
    } else if (t.tag === 'Lambda') {
      // With HOAS, the body is a function. To find holes inside,
      // you must apply it to a dummy variable and traverse the result.
      const dummyVar = { tag: 'Var', name: t.binderName };
      traverse(t.body(dummyVar));
    }
    // ... other term constructors
  }
  traverse(term);
  return holes;
}

/**
 * Generates a human-readable report of the current proof state.
 */
function reportProofState(term: Term): string {
  const unsolvedHoles = findHoles(term);
  if (unsolvedHoles.length === 0) {
    return "Proof complete. No goals remain.";
  }

  let reportStr = `Proof has ${unsolvedHoles.length} unsolved goal(s):\n`;
  
  for (const hole of unsolvedHoles) {
    reportStr += `\n------------------\n`;
    reportStr += `Goal ${hole.id}:\n`;
    hole.context.forEach(v => {
      reportStr += `  ${v.name} : ${toString(v.type)}\n`;
    });
    reportStr += `  ⊢ ${toString(hole.type)}\n`;
  }
  return reportStr;
}
```

**2. The Core Primitive: `refine`**

This is the single, powerful function for making progress. It modifies a *copy* of the hole to maintain immutability (or mutates in place if that's your design).

```typescript
/**
 * Refines a specific hole within a proof term with a new sub-term.
 * Returns a new proof term with the refinement applied.
 */
function refine(proofTerm: Term, holeId: string, refinementTerm: Term): Term {
  // 1. Find the target hole object within the proof term. This requires a traversal.
  // We need a function that returns the hole object *itself* so we can modify its `ref`.
  const targetHole = findHoleById(proofTerm, holeId); // Assume this function exists.
  if (!targetHole || targetHole.ref !== null) {
    throw new Error(`Hole ${holeId} not found or is already solved.`);
  }

  // 2. Elaborate the refinement term.
  // This step uses the type checker to check the refinementTerm in the hole's context
  // and to instantiate any new holes `_?` within it.
  // The type checker must be able to create new Hole objects on the fly.
  const elaboratedRefinement = kernel.check(targetHole.context, refinementTerm, targetHole.type);
  // If checking throws an error, the refine fails, which is correct.

  // 3. Solve the hole.
  // In an immutable system, you'd clone the proof term and update the ref.
  // For simplicity here, we'll show the mutable version.
  targetHole.ref = elaboratedRefinement;

  return proofTerm; // Return the top-level term, which now contains the solved hole.
}
```

**3. Convenience Wrappers ("Tactics")**

These are just regular TypeScript functions that build a `refinementTerm` and then call `refine`.

```typescript
function intro(proofTerm: Term, holeId: string, varName: string): Term {
  const targetHole = findHoleById(proofTerm, holeId);
  if (!targetHole) throw new Error(`Hole ${holeId} not found.`);

  // Check if the goal is a function type
  if (targetHole.type.tag !== 'Pi') {
    throw new Error('`intro` tactic requires a function type (Π-type) goal.');
  }

  // Construct the refinement term: λ(varName). ?NewHole
  const newHolePlaceholder = { tag: 'UserHolePlaceholder' }; // A temporary syntax for `_?`
  const lambdaTerm = {
    tag: 'Lambda',
    binderName: varName,
    binderType: targetHole.type.domain,
    body: (v: Term) => newHolePlaceholder 
  };

  // The `refine` function will replace the placeholder with a real, elaborated Hole.
  return refine(proofTerm, holeId, lambdaTerm);
}

function exact(proofTerm: Term, holeId: string, solutionTerm: Term): Term {
  // `exact` is just `refine` with a term that is expected to be complete.
  // The `refine` function's internal call to `kernel.check` will verify this.
  return refine(proofTerm, holeId, solutionTerm);
}
```

---

### Part 3: Example Walkthrough (New API)

Let's trace the `nat -> bool` proof again with this stateless API.

```typescript
// Developer's side TypeScript code:

// 1. Start the proof by creating the initial goal.
let myProof = createGoal(NatToBoolType);

// 2. Check the status.
console.log(reportProofState(myProof));
// Output:
// Proof has 1 unsolved goal(s):
//
// ------------------
// Goal ?1:
//   ⊢ nat -> bool

// 3. Get the ID of the active hole and apply the `intro` tactic.
const holes = findHoles(myProof);
const activeHoleId = holes[0].id; // Let's say it's "?1"

myProof = intro(myProof, activeHoleId, 'n'); // Re-assign myProof to the new term

// 4. Check the status again. The new term now has a new hole inside the lambda.
console.log(reportProofState(myProof));
// Output from a smart `reportProofState`:
// Proof has 1 unsolved goal(s):
//
// ------------------
// Goal ?2:
//   n : nat
//   ⊢ bool

// 5. Let's solve the remaining goal using `exact`.
const newHoles = findHoles(myProof);
const newActiveHoleId = newHoles[0].id; // This will be "?2"

const solution = Apply(IsEven, Var('n'));
myProof = exact(myProof, newActiveHoleId, solution);

// 6. Check the final status.
console.log(reportProofState(myProof));
// Output:
// Proof complete. No goals remain.

// `myProof` is now the fully constructed term. We can normalize it
// to get a clean version and add it to the global environment.
const finalTerm = normalize(myProof);
// globalEnv.define('my_func', finalTerm);
```
