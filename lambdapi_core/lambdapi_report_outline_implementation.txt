## Lambdapi Core: A Deep Dive into Implementation Techniques

This analysis is based on the provided OCaml source files.

**Overall Architecture:**

The core of Lambdapi is structured around several key concepts:

1.  **Terms (`term.ml`):** A central, richly-featured internal representation for terms, types, patterns, and metavariables.
2.  **Signatures (`sign.ml`, `sig_state.ml`):** Manages defined symbols, their properties (type, rules, notations, implicits), and module-level scoping. `sig_state.ml` provides a higher-level interface over `sign.ml`.
3.  **Contexts (`ctxt.ml`, `env.ml`):** `ctxt.ml` defines typing contexts (variable -> type/definition) used during checking and evaluation. `env.ml` is likely for an earlier parsing/scoping stage (name -> variable).
4.  **Type Inference & Checking (`infer.ml`):** Implements a bidirectional-style type system, generating unification constraints.
5.  **Unification (`unif.ml`):** Solves constraints generated by the type inferencer, instantiating metavariables. Supports unification rules.
6.  **Evaluation & Rewriting (`eval.ml`):** Handles term reduction (beta, delta, user-defined rules) using decision trees.
7.  **Decision Trees (`tree.ml`, `tree_type.ml`):** Compiles rewrite rules into efficient decision trees for pattern matching.
8.  **Metavariables (`libMeta.ml`):** Utilities for creating and managing metavariables (holes).
9.  **Builtins (`builtin.ml`):** Mechanism for registering and checking predefined symbols.

---

### 1. Term Representation (`term.ml`)

*   **`term` type:** This is a GADT-like sum type encompassing:
    *   `Vari`: Free variables (unique ID + name).
    *   `Bvar`: Bound variables (de Bruijn-like, `InSub` for current binder, `InEnv` for outer binders via closure).
    *   `Type`, `Kind`: Sorts.
    *   `Symb of sym`: User-defined symbols.
    *   `Prod`, `Abst`: Dependent product (Π) and lambda abstraction (λ).
    *   `Appl`: Application.
    *   `Meta of meta * term array`: Metavariable application (hole with explicit substitutions for its context).
    *   `Patt of int option * string * term array`: Pattern variable. `int option` is the index if named (for RHS), `string` is the name, `term array` are arguments if it's a higher-order pattern variable.
    *   `Wild`: Wildcard, distinct from unnamed `Patt`.
    *   `Plac of bool`: Placeholder for yet-to-be-inferred terms (true if it's a type).
    *   `TRef of term option Timed.ref`: Mutable reference, used for evaluation with sharing and possibly surface matching.
    *   `LLet`: Let-bindings.

*   **`sym` record:** Rich representation for symbols.
    *   `sym_impl: bool list`: Crucially, stores which arguments are implicit. `true` = implicit.
    *   `sym_type: term Timed.ref`: The type of the symbol.
    *   `sym_def: term option Timed.ref`: Optional definitional equality.
    *   `sym_rules: rule list Timed.ref`: List of rewrite rules.
    *   `sym_dtree: dtree Timed.ref`: Compiled decision tree for its rules.
    *   `sym_not: float notation Timed.ref`: Pretty-printing notation.
    *   `sym_prop: prop`: Properties like `Const`, `Injec`, `Commu`, `Assoc`, `AC`.

*   **`rule` record:**
    *   `lhs: term list`: The arguments of the LHS pattern. The head symbol is implicit.
    *   `rhs: term`: The right-hand side.
    *   `names: string array`: Names of pattern variables.
    *   `arity: int`: Number of arguments in `lhs`.
    *   `arities: int array`: Arities of pattern variables bound in RHS (for higher-order patterns).
    *   `vars_nb`: Number of distinct pattern variables in LHS.
    *   `xvars_nb`: Number of "extra" variables in RHS not in LHS (for unification rules).

*   **`meta` record:**
    *   `meta_key: int`: Unique ID.
    *   `meta_type: term Timed.ref`: Type of the metavariable.
    *   `meta_arity: int`: Number of variables in its context.
    *   `meta_value: mbinder option Timed.ref`: Its eventual instantiation (a binder capturing its context).

*   **Smart Constructors:** `mk_Appl`, `mk_Prod`, etc., ensure invariants (e.g., AC normalization for `mk_Appl`). `add_args` is the general application builder.

*   **`unfold` function:** Essential for evaluation and matching. It peels off `TRef`s and instantiated `Meta`s to get to the "real" term underneath. Most functions operate on unfolded terms.

### 2. Binder Representation

Lambdapi uses a **hybrid approach, primarily HOAS-like at the interface with explicit closure environments for non-local bound variables.**

*   **`binder = binder_info * term * term array`**
*   **`mbinder = mbinder_info * term * term array`** (for multi-binders, e.g., in metavariable values)

    *   `binder_info`: Contains `binder_name` (string) and `binder_bound` (bool, tracks if the bound var is actually used).
    *   `term`: The body of the binder.
    *   `term array`: The closure environment. This stores terms that were free in the body *before* binding but become captured.

*   **`Bvar` (Bound Variable):**
    *   `InSub k`: Refers to the k-th variable bound by the *immediate* parent binder (de Bruijn index 0 for the innermost).
    *   `InEnv k`: Refers to the k-th term in the closure environment of the parent binder. This is how variables from *ancestor* binders are accessed.

*   **Interface:**
    *   `bind_var x t`: Takes a free variable `x` and a term `t`. It traverses `t`, replacing occurrences of `x` with `Bvar (InSub 0)`. Other free variables in `t` are collected into the closure environment.
    *   `unbind b`: Takes a binder `b`. Creates a fresh free variable `x` and substitutes `Bvar (InSub 0)` in the binder's body with `Vari x`. Terms from the closure environment are substituted for `Bvar (InEnv k)`.
    *   `subst b v`: Substitutes the variable bound by `b` with `v`. Similar logic to `unbind`.
    *   `msubst mb vs`: For multi-binders, substitutes with an array of values.

**Advantages:**
*   Alpha-equivalence is cheap (handled by `eq_vars` on fresh vars from `unbind`).
*   Substitution is defined structurally and correctly handles capture.

**Complexity:** The `bind_var` and `subst`/`unbind` operations involve term traversal. The closure environment ensures that substitutions don't need to deeply recurse through unrelated binders.

### 3. Type Inference, Checking, and Elaboration (`infer.ml`)

Lambdapi employs a **bidirectional type checking** strategy.

*   **`infer pb ctxt term` (Synthesis Mode):**
    *   Takes a `problem` (for unification constraints), a `ctxt` (typing context), and a `term`.
    *   Returns `(elaborated_term, inferred_type, modified_flag)`.
    *   The `modified_flag` is true if placeholders were filled or coercions applied.
    *   This function synthesizes the type of the term.
    *   For `Plac false` (term placeholder), it creates two metavariables: one for the term (`m`) and one for its type (`mt`), returning `(m, mt)`.
    *   For `Plac true` (type placeholder), it creates one metavariable for the type (`m`), returning `(m, mk_Type)`.

*   **`force pb ctxt term expected_type` (Checking Mode):**
    *   Takes a `problem`, `ctxt`, `term`, and an `expected_type`.
    *   Returns `(elaborated_term, modified_flag)`.
    *   Checks if `term` has `expected_type`. If not, it infers the type of `term` (`actual_type`) and tries to coerce `term` from `actual_type` to `expected_type`.
    *   Coercion: If `actual_type` and `expected_type` are not convertible (`Eval.pure_eq_modulo`), it attempts `Coercion.apply actual_type expected_type term`. If this reduction via `Coercion.coerce` doesn't fully resolve, it adds a unification constraint `actual_type == expected_type` to the `problem`.

*   **`type_enforce pb ctxt term` (Sort Checking):**
    *   Ensures `term` is a type (i.e., has type `Type` or `Kind`). Infers the type of `term` and coerces it to `Type` (default) or `Kind`.

*   **Elaboration:**
    *   The `infer` and `force` functions perform elaboration implicitly. When they encounter `Plac` (placeholders/holes), they replace them with fresh metavariables (`LibMeta.make`).
    *   Implicit arguments are handled during the application case (`Appl(t,u)`). When inferring the type of `t`, if it's a Π-type `Πx:A.B`, `u` is `force`d against `A`. If `t`'s type is a metavariable, new metavariables are created for the domain and codomain of an expected Π-type.
    *   The returned `elaborated_term` is the term with holes filled by metavariables and potentially modified by coercions.

*   **Unification Constraints:**
    *   `unif pb ctxt t1 t2`: If `t1` and `t2` are not convertible via `Eval.pure_eq_modulo`, a constraint `(ctxt, t1, t2)` is added to `!pb.to_solve`.

### 4. Holes and Metavariables (`libMeta.ml`, `infer.ml`)

*   Holes in the surface syntax are parsed as `Plac` terms.
*   During type inference/checking (`infer.ml`):
    *   `Plac false` (term hole) becomes `mk_Meta(m, context_vars)` where `m` is a fresh metavariable. Its type is also a fresh metavariable.
    *   `Plac true` (type hole) becomes `mk_Meta(m, context_vars)` where `m` is a fresh metavariable. Its type is `mk_Type`.
*   `LibMeta.make pb ctxt type`: Creates a fresh metavariable term of the given `type` in `ctxt`, adding it to the `problem` `pb`.
*   Metavariables are instantiated by the unification algorithm (`unif.ml`).
    *   `LibMeta.set pb meta value_binder`: Sets the `meta_value` of `meta` to `value_binder` (an `mbinder` capturing the meta's context) and removes it from the active metas in `pb`.

### 5. Implicit Arguments

*   **Declaration:** Stored in `sym.sym_impl: bool list`. `true` means implicit.
*   **Elaboration (Application `f t1 ... tn`):**
    *   This is primarily handled during type checking of applications in `infer.ml`.
    *   When checking `Appl(f, arg)`:
        1.  Infer type of `f` (say `Tf`).
        2.  `Tf` is expected to be a Π-type, `Π (x:A) B`.
        3.  If `x` is an implicit argument (checked from `f.sym_impl` if `f` is a `Symb`):
            *   A fresh metavariable `M` is created for `x` with type `A`.
            *   The application effectively becomes `f M`, and the process continues to check this new application against the next explicit argument.
            *   The type of `f M` is `B[M/x]`.
        4.  If `x` is explicit:
            *   `arg` is checked against type `A` (using `force`).
            *   The type of `f arg` is `B[arg/x]`.
    *   This process continues until all explicit arguments are consumed or the type of the function is no longer a Π-type.
*   **Printing (`print.ml`):** `LibTerm.remove_impl_args s ts` is used to filter out implicit arguments before printing if `!print_implicits` is false. This function iterates through `s.sym_impl` and the provided arguments `ts`, skipping arguments corresponding to `true` in `s.sym_impl`.
*   **Pattern Matching (LHS of rules):** See dedicated section below.

### 6. Unification (`unif.ml`)

*   **Algorithm:** A standard first-order unification algorithm with extensions for metavariables and higher-order patterns (flex-rigid, flex-flex).
*   **`solve pb`:** The main loop. Iteratively processes constraints from `!pb.to_solve`.
    *   If `t1` and `t2` are convertible (`Eval.pure_eq_modulo`), the constraint is discharged.
    *   **Decomposition:** `f t1 ... tn === f u1 ... un` (where `f` is rigid and injective) becomes `t1===u1, ..., tn===un`.
    *   **Metavariable Instantiation (`instantiate`):** For `M vs === t` (where `M` is a meta, `vs` are distinct variables, `M` doesn't occur in `t`):
        *   `M` is set to `λxs. t'` where `xs` are fresh vars corresponding to `vs`, and `t'` is `t` with `vs` replaced by `xs` and potentially simplified (`Eval.beta_simplify`).
        *   Requires `nl_distinct_vars vs` to succeed.
        *   Type checking of the instantiation can be enabled/disabled (`!do_type_check`).
    *   **Imitation (`imitate_prod`, `imitate_inj`, `imitate_lam`):**
        *   `M vs === Πx:A.B`: `M` is instantiated to `λxs. Πy:(M1 xs). (M2 xs y)`.
        *   `M vs === f t1 ... tn` (`f` injective): `M` is instantiated to `λxs. f (M1 xs) ... (Mn xs)`.
        *   `M vs u === t`: If `u` is `Vari x` and `x` is "fresh" wrt `M vs`, `M` is instantiated to `λxs. λx'. (M' xs x')`.
    *   **Occurs Check:** `LibMeta.occurs m c t` checks if meta `m` occurs in `t` (unfolding context `c`).
    *   **Rigid-Rigid Clashes:** `f ... === g ...` where `f =/= g` and both are rigid leads to failure (`Unsolvable` exception).
    *   **Unsolved Constraints:** If no rule applies, the constraint is moved to `!pb.unsolved`. The `recompute` flag triggers another pass if metas were instantiated.
*   **Unification Rules (`unif_rule.ml`, `unif.ml::try_unif_rules`):**
    *   Users can define rules like `(t1 === t2) --> (u1 === v1); (u2 === v2)`.
    *   These are represented using special symbols `Unif_rule.equiv` (for `===`) and `Unif_rule.cons` (for `;`).
    *   `try_unif_rules` attempts to rewrite a constraint `c |- s === t` by evaluating `equiv s t` (or `equiv t s`) using the standard `Eval.whnf`. If it reduces to a `cons` list of new `equiv` terms, these new problems are added.

### 7. Pattern Matching and Rewrite Rules (`eval.ml`, `tree.ml`, `tree_type.ml`)

This is a sophisticated part of Lambdapi.

*   **Rule Compilation (`tree.ml::compile`, `CM` module):**
    1.  **Clause Matrix (`CM.t`):** Rewrite rules for a symbol are initially converted into a "clause matrix" (`CM.of_rules`). Each row is a `clause` containing:
        *   `c_lhs: term array`: The pattern arguments.
        *   `c_rhs: rule`: The original rule structure (for RHS, variable names, etc.).
        *   `c_subst: rhs_substit`: Accumulates information for RHS instantiation.
        *   `cond_pool: CP.t`: Non-linearity and free-variable conditions.
    2.  **Decision Tree (`Tree_type.tree`):** The `compile` function recursively transforms the clause matrix into a decision tree.
        *   `CM.yield`: Heuristically decides the next step:
            *   `Yield clause`: A pattern is fully matched, create a `Leaf` node.
            *   `Condition tree_cond`: Choose a condition (NL or FV) from `cond_pool` and create a `Cond` node.
            *   `Specialise col_idx`: Choose a column to inspect. Create a `Node` node.
            *   `Check_stack`: For sequential strategies with varying arities, create an `Eos` node.
        *   `Node` creation:
            *   `swap`: Index of the argument in the current term's argument stack to inspect.
            *   `store`: Boolean, true if the term at `swap` needs to be stored for RHS or conditions.
            *   `children: TCMap.t`: A map from `Tree_type.TC.t` (symbol, variable, type) to sub-trees. This is built by `CM.specialize`.
            *   `abstraction`, `product`: Sub-trees for matching λ and Π binders, built by `CM.binder`.
            *   `default`: Sub-tree for wildcard/variable patterns, built by `CM.default`.
    3.  The compiled `dtree` (a lazy pair of capacity and tree) is stored in `sym.sym_dtree`.

*   **Elaboration of Patterns (LHS):**
    *   **Implicit Arguments in LHS Symbols:** When a rule `f P1 ... Pn := Q` is parsed and scoped (likely in `scope.ml` using parsers from `lpParser.mly`), the terms `P1 ... Pn` (and `Q`) are converted into `Term.term`s.
    *   If `Pi` contains a literal symbol `g` (e.g., `Pi` is `g R1 R2`), and `g` has implicit arguments, the normal term elaboration process (similar to `infer.ml`'s logic) would insert placeholders (`Plac`) for these implicits during scoping. These `Plac`s would then be turned into metavariables.
    *   **However, for pattern matching, LHS patterns must be concrete up to pattern variables.** Metavariables (holes) are generally not allowed in the LHS of rewrite rules after parsing/scoping. The system expects to match against fully known structures or pattern variables.
    *   If implicit arguments for symbols *within* a pattern are meant to be *inferred based on the term being matched*, this would be a very advanced feature. The current structure suggests a simpler model:
        *   Either implicits in LHS symbols are filled with wildcards/pattern variables if they can't be determined statically.
        *   Or, more likely, the user is expected to provide explicit arguments or pattern variables for those slots if they matter for the match.
        *   The `Tree.compile` function takes `Term.rule list`, where `lhs` is `Term.term list`. These terms are assumed to be "as explicit as needed" for matching. The `dtree` matches based on the structure of these terms.
    *   `LibTerm.remove_impl_args` is a utility for *removing* implicits (e.g., for printing), not for *filling them in* within patterns during matching.
    *   **Conclusion on Pattern Elaboration for Implicits:** The system does *not* seem to perform a special "elaboration of implicit arguments for patterns using the type of the matched term" *during the matching phase*. Any implicit arguments for symbols *literally appearing* in the LHS pattern are resolved (likely to explicit pattern variables or concrete terms if possible) when the rule itself is first parsed and scoped into the `Term.rule` structure. The `tree_walk` then matches against this pre-processed LHS structure. The `sym_impl` field of the *head symbol of the rule* dictates how many arguments from the input term stack are initially taken to match `rule.lhs`.

*   **Matching (`eval.ml::tree_walk`):**
    1.  Takes `config`, `dtree`, and `stack` (current term's arguments).
    2.  Traverses the `dtree`:
        *   `Leaf(rhs_subst, rule_struct)`: Match successful.
            *   `env` for RHS is built using `rhs_subst` and the `vars` array (which collected matched subterms).
            *   `Term.subst_patt env rule_struct.rhs` instantiates the RHS.
        *   `Cond({ok; cond; fail})`:
            *   `CondNL(i,j)`: Checks `Eval.eq_modulo cfg vars.(i) vars.(j)`.
            *   `CondFV(i,xs)`: Checks free variables in `vars.(i)` against allowed `xs`.
            *   Recurses into `ok` or `fail` tree.
        *   `Eos(left, right)`: If `stack` is empty, go `left`, else `right`.
        *   `Node({swap; store; children; ...})`:
            *   Examines `stack.(swap)`.
            *   `whnf_stk` normalizes this argument.
            *   If `store` is true, the (normalized) argument is put into the `vars` array at current `cursor`.
            *   Its head constructor (`TC.t`) is used to find the next subtree in `children`.
            *   If it's an `Abst` or `Prod`, the `abstraction` or `product` subtree is used.
            *   If no specific match, `default` subtree is used.
            *   Arguments of the matched head are pushed back onto the stack for further matching by subtrees.

**How `Patt` terms in LHS are handled by `tree_walk`:**
*   Pattern variables (`Patt`) in the LHS of rules guide the construction of the `dtree`.
*   A `Patt(Some idx, name, args)` (named pattern variable):
    *   If it's at a position `k` being specialized, it often leads to the `default` branch of a `Node`.
    *   When `tree_walk` takes this `default` branch, the term `u` that didn't match any specific constructor is effectively matched by this pattern variable.
    *   If the `Node` had `store=true`, `u` (or its WHNF) is placed in `vars[slot_for_k]`.
    *   The `rhs_substit` in a `Leaf` will map `vars[slot_for_k]` to the `idx`-th variable in the RHS.
*   A `Patt(None, name, args)` (unnamed pattern variable, wildcard):
    *   Similar to above, but doesn't contribute to `rhs_substit`.
*   Higher-order pattern variables (where `Patt(_,_,args)` has non-empty `args`): The `args` part of the pattern is matched against the arguments of the term that `Patt` is matching. This is complex and relies on the arities stored in the rule and the structure of the dtree.

---

### Summary of Strengths and Techniques:

*   **Strong Foundational `Term` Representation:** Well-suited for various operations.
*   **Hybrid Binder (HOAS-like with Closures):** Good balance for alpha-equivalence and substitution.
*   **Bidirectional Type Checking:** Efficient and user-friendly for common cases, falling back to inference with metavariables for harder cases.
*   **Metavariable-based Inference:** Standard and powerful technique for type inference and hole resolution.
*   **Sophisticated Rewriting Engine:** Decision trees (Maranget-style) provide efficient pattern matching.
*   **Explicit Control over Evaluation:** `Config` in `eval.ml` allows fine-tuning reduction strategies.
*   **Clear Separation of Concerns:** Modules like `term`, `infer`, `eval`, `unif`, `tree` have distinct responsibilities.
*   **Handling of Implicits:** Integrated into type checking and managed via `sym.sym_impl`.
*   **Unification Rules:** Extensible unification capabilities.

This is a very robust and well-designed core for a proof assistant, incorporating many established and advanced techniques from the field of type theory and functional programming language implementation. The specific handling of pattern elaboration and matching, while not performing on-the-fly implicit argument inference for patterns during matching, is sound and relies on pre-processing the rule's LHS into a concrete structure (with pattern variables) that the decision tree can efficiently work with.